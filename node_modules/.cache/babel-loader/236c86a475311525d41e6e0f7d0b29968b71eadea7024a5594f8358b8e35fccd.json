{"ast":null,"code":"export const util = {\n  /* Clona objeto */\n  clone: obj => {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n    var temp = obj.constructor();\n    for (var key in obj) {\n      temp[key] = util.clone(obj[key]);\n    }\n    return temp;\n  },\n  /* Verifica si es NO nulo */\n  isNotNull: v => {\n    return !util.isNull(v);\n  },\n  /* Verifica si es  nulo */\n  isNull: v => {\n    if (v === undefined || v === null) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n  isIntersectSet(A, B) {\n    //if (Array.isArray(A)) { A=new Set(A); }\n    //if (Array.isArray(B)) { B=new Set(B); }\n    let setA = new Set(A);\n    let setB = new Set(B);\n    let _intersection = new Set();\n    for (let elem of setB) {\n      if (setA.has(elem)) {\n        _intersection.add(elem);\n      }\n    }\n    return _intersection.size > 0 ? true : false;\n  },\n  strToNull: v => {\n    if (util.isNull(v) || v == '') {\n      return null;\n    } else {\n      return v;\n    }\n  }\n};","map":{"version":3,"names":["util","clone","obj","temp","constructor","key","isNotNull","v","isNull","undefined","isIntersectSet","A","B","setA","Set","setB","_intersection","elem","has","add","size","strToNull"],"sources":["/opt/rdx-vitrina-front/src/helpers/util.js"],"sourcesContent":["\n\nexport const util  = { \n    /* Clona objeto */ \n    clone: (obj) => {\n        if ( obj === null || typeof obj  !== 'object' ) {\n            return obj;\n        }\n        var temp = obj.constructor();\n        for ( var key in obj ) {\n            temp[ key ] = util.clone( obj[ key ] );\n        }\n        return temp;\n    },\n    /* Verifica si es NO nulo */\n    isNotNull: (v) => {\n        return ! util.isNull(v);\n    },\n    \n    /* Verifica si es  nulo */\n    isNull: (v) => {\n        if (v === undefined || v === null) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    },\n    \n    isIntersectSet(A,B) {\n    \n       //if (Array.isArray(A)) { A=new Set(A); }\n       //if (Array.isArray(B)) { B=new Set(B); }\n       let setA=new Set(A);\n       let setB=new Set(B);\n       let _intersection = new Set()\n       for (let elem of setB) {\n         if (setA.has(elem)) {\n           _intersection.add(elem)\n         }\n       }\n       return (_intersection.size>0)?true:false;\n   }, \n   \n   strToNull: (v) => {\n        if (util.isNull(v) || v=='')  {\n          return null;\n        }\n        else  {\n           return v;\n        }\n    },\n       \n};"],"mappings":"AAEA,OAAO,MAAMA,IAAI,GAAI;EACjB;EACAC,KAAK,EAAGC,GAAG,IAAK;IACZ,IAAKA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAM,QAAQ,EAAG;MAC5C,OAAOA,GAAG;IACd;IACA,IAAIC,IAAI,GAAGD,GAAG,CAACE,WAAW,EAAE;IAC5B,KAAM,IAAIC,GAAG,IAAIH,GAAG,EAAG;MACnBC,IAAI,CAAEE,GAAG,CAAE,GAAGL,IAAI,CAACC,KAAK,CAAEC,GAAG,CAAEG,GAAG,CAAE,CAAE;IAC1C;IACA,OAAOF,IAAI;EACf,CAAC;EACD;EACAG,SAAS,EAAGC,CAAC,IAAK;IACd,OAAO,CAAEP,IAAI,CAACQ,MAAM,CAACD,CAAC,CAAC;EAC3B,CAAC;EAED;EACAC,MAAM,EAAGD,CAAC,IAAK;IACX,IAAIA,CAAC,KAAKE,SAAS,IAAIF,CAAC,KAAK,IAAI,EAAE;MAC/B,OAAO,IAAI;IACf,CAAC,MACI;MACD,OAAO,KAAK;IAChB;EACJ,CAAC;EAEDG,cAAc,CAACC,CAAC,EAACC,CAAC,EAAE;IAEjB;IACA;IACA,IAAIC,IAAI,GAAC,IAAIC,GAAG,CAACH,CAAC,CAAC;IACnB,IAAII,IAAI,GAAC,IAAID,GAAG,CAACF,CAAC,CAAC;IACnB,IAAII,aAAa,GAAG,IAAIF,GAAG,EAAE;IAC7B,KAAK,IAAIG,IAAI,IAAIF,IAAI,EAAE;MACrB,IAAIF,IAAI,CAACK,GAAG,CAACD,IAAI,CAAC,EAAE;QAClBD,aAAa,CAACG,GAAG,CAACF,IAAI,CAAC;MACzB;IACF;IACA,OAAQD,aAAa,CAACI,IAAI,GAAC,CAAC,GAAE,IAAI,GAAC,KAAK;EAC5C,CAAC;EAEDC,SAAS,EAAGd,CAAC,IAAK;IACb,IAAIP,IAAI,CAACQ,MAAM,CAACD,CAAC,CAAC,IAAIA,CAAC,IAAE,EAAE,EAAG;MAC5B,OAAO,IAAI;IACb,CAAC,MACK;MACH,OAAOA,CAAC;IACX;EACJ;AAEJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}